"Profile Bazel builds with gangaji"

# Extension version - updated during release
GANGAJI_VERSION = "v0.0.0"

def _get_platform(ctx):
    """Determine the current platform for binary download."""
    os = ctx.std.env.os()
    arch = ctx.std.env.arch()

    if os == "macos":
        os = "darwin"
    elif os == "windows":
        os = "windows"
    else:
        os = "linux"

    if arch == "x86_64":
        arch = "amd64"
    elif arch == "aarch64":
        arch = "arm64"

    return os, arch

def _download_gangaji(ctx, version):
    """Download gangaji binary from GitHub releases."""
    os, arch = _get_platform(ctx)

    ext = ".tar.gz"
    if os == "windows":
        ext = ".zip"

    # Release tag has "v" prefix, but archive filename doesn't
    version_no_v = version[1:] if version.startswith("v") else version

    url = "https://github.com/thesayyn/gangaji/releases/download/{tag}/gangaji_{version}_{os}_{arch}{ext}".format(
        tag = version,
        version = version_no_v,
        os = os,
        arch = arch,
        ext = ext,
    )

    home_dir = ctx.std.env.home_dir()
    gangaji_dir = home_dir + "/.cache/gangaji/" + version
    gangaji_bin = gangaji_dir + "/gangaji"
    if os == "windows":
        gangaji_bin = gangaji_bin + ".exe"

    # Check if already downloaded
    if ctx.std.fs.exists(gangaji_bin):
        return gangaji_bin

    ctx.std.fs.create_dir_all(gangaji_dir)

    archive_path = gangaji_dir + "/gangaji" + ext

    out = ctx.std.io.stdout
    out.write("Downloading gangaji " + version + " from " + url + "\n")

    # Download the archive
    ctx.http().download(url = url, mode = 0o755, output = archive_path).block()

    # Extract the archive
    ctx.std.process.command("tar").args(["-xzf", archive_path, "-C", gangaji_dir]).spawn().wait()

    # Clean up archive
    ctx.std.fs.remove_file(archive_path)

    return gangaji_bin

def _profile_impl(ctx):
    """Run Bazel with profiling and analyze with gangaji."""
    out = ctx.std.io.stdout
    err = ctx.std.io.stderr
    is_tty = out.is_tty

    # Get version from extension
    version = GANGAJI_VERSION

    # Determine profile output path
    profile_path = ctx.std.env.current_dir() + "/bazel-profile.json.gz"

    # Get targets from args (default to //...)
    targets = list(ctx.args.targets) if ctx.args.targets else ["//..."]
    extra_args = list(ctx.args.extra_args) if ctx.args.extra_args else []
    clean = ctx.args.clean

    # Build the bazel arguments - flags before targets
    flags = ["--profile", profile_path, "--generate_json_trace_profile"] + extra_args
    if is_tty:
        flags.append("--isatty")

    # If clean flag is set, use a temporary output_base
    output_base = None
    startup_flags = []
    if clean:
        # Hash the project directory to create a unique output_base per project
        project_dir = ctx.std.env.root_dir()
        project_hash = str(hash(project_dir))
        output_base = ctx.std.env.temp_dir() + "/gangaji-clean-build-" + project_hash
        startup_flags = ["--output_base", output_base]
        # Clean up any existing output_base before starting
        if ctx.std.fs.exists(output_base):
            out.write("Cleaning up existing output_base: " + output_base + "\n")
            # Bazel creates files with restricted permissions, fix them before deletion
            ctx.std.process.command("chmod").args(["-R", "u+rwx", output_base]).spawn().wait()
            ctx.std.fs.remove_dir_all(output_base)
        # Remove bazel-* symlinks that point to old output_base
        for entry in ctx.std.fs.read_dir(project_dir):
            symlink_path = entry.path
            name = symlink_path.split("/")[-1]
            if name.startswith("bazel-"):
                metadata = ctx.std.fs.symlink_metadata(symlink_path)
                if metadata and metadata.is_symlink:
                    out.write("Removing stale symlink: " + symlink_path + "\n")
                    ctx.std.fs.remove_file(symlink_path)
        out.write("Using clean build with output_base: " + output_base + "\n")

    out.write("Running: bazel build " + " ".join([str(a) for a in flags]) + "\n\n")

    # Run bazel with profiling
    build = ctx.bazel.build(
        startup_flags = startup_flags,
        flags = flags,
        *targets
    )
    result = build.wait()

    # Clean up temporary output_base if using clean build
    if output_base and ctx.std.fs.exists(output_base):
        out.write("Cleaning up output_base: " + output_base + "\n")
        # Bazel creates files with restricted permissions, fix them before deletion
        ctx.std.process.command("chmod").args(["-R", "u+rwx", output_base]).spawn().wait()
        ctx.std.fs.remove_dir_all(output_base)

    if not result.success:
        err.write("\nBazel command failed with exit code " + str(result.code) + "\n")
        return 1

    # Check if profile was generated
    if not ctx.std.fs.exists(profile_path):
        err.write("Error: Profile file was not generated at " + profile_path + "\n")
        return 1

    out.write("\nProfile saved to: " + profile_path + "\n")

    # Download gangaji
    gangaji_bin = _download_gangaji(ctx, version)

    out.write("Opening profile with gangaji...\n\n")

    # Run gangaji on the profile
    child = ctx.std.process.command(gangaji_bin).arg("--profile=" + profile_path).spawn()
    code = child.wait()

    return code

profile = task(
    implementation = _profile_impl,
    args = {
        "targets": args.positional(),
        "clean": args.boolean(),
        "extra_args": args.trailing_var_args(),
    },
)
